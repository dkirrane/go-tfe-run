// Package tferun provides a single method Run to create and follow up a new
// run on Terraform Enterprise or Cloud.
package tferun

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/avast/retry-go"
	"github.com/hashicorp/go-tfe"
)

// RunOptions groups all options available when creating a new run.
type RunOptions struct {
	// Token is used to communicate with the Terraform Cloud API. Must be a
	// user or team API token.
	Token string
	// The organization on Terraform Cloud.
	Organization string
	// The workspace on Terraform Cloud.
	Workspace string
	// Message to use as name of the run.
	Message string
	// The directory that is uploaded to Terraform Cloud, respects
	// .terraformignore.
	Directory string
	// Whether to create a speculative run. A speculative run can not be
	// applied.
	Speculative bool
	// Whether we should wait for the non-speculative run to be applied. This
	// will block until the run is finished.
	WaitForCompletion bool
	// Contents of a auto.tfvars file that will be uploaded to Terraform Cloud.
	// This can be used to set Terraform variables. These variables will not be
	// persisted.
	TfVars string
}

// Output holds the data that is generated by a run.
type Output struct {
	// URL to the run on Terraform Cloud
	RunURL string
	// Whether this run has changes. After a speculative plan this would
	// indicate whether plan would cause changes, after a non-speculative run
	// this indicates whether the run has caused any changes.
	// This is not populated for non-speculative runs on workspaces that do not
	// have auto-apply configured or when WaitForCompletion is not set.
	HasChanges bool
	// Current outputs from the Terraform project.
	// This is not populated for non-speculative runs on workspaces that do not
	// have auto-apply configured or when WaitForCompletion is not set.
	TfOutputs map[string]string
}

// Run creates a new run on Terraform Cloud.
func Run(ctx context.Context, options RunOptions) (output Output, err error) {
	config := &tfe.Config{
		Token: options.Token,
	}
	client, err := tfe.NewClient(config)
	if err != nil {
		err = fmt.Errorf("could not create a new TFE client: %w", err)
		return
	}

	w, err := client.Workspaces.Read(ctx, options.Organization, options.Workspace)
	if err != nil {
		err = fmt.Errorf("could not retrieve workspace '%v/%v': %w", options.Organization, options.Workspace, err)
		return
	}

	cvOptions := tfe.ConfigurationVersionCreateOptions{
		// Don't automatically queue the new run, we want to create the run
		// manually to set the message.
		AutoQueueRuns: tfe.Bool(false),
		Speculative:   &options.Speculative,
	}
	cv, err := client.ConfigurationVersions.Create(ctx, w.ID, cvOptions)
	if err != nil {
		if err == tfe.ErrResourceNotFound {
			err = fmt.Errorf("could not create configuration version (404 not found), this might happen if you are not using a user or team API token")
		} else {
			err = fmt.Errorf("could not create a new configuration version: %w", err)
		}
		return
	}

	if options.TfVars != "" {
		// Creating a *.auto.tfvars file that is uploaded with the rest of the
		// code is the easiest way to temporarily set a variable. The Terraform
		// Cloud API only allows setting workspace variables. These variables
		// are persistent across runs which might cause undesired side-effects.
		varsFile := filepath.Join(options.Directory, w.WorkingDirectory, "run.auto.tfvars")

		fmt.Printf("Creating variables file %v\n", varsFile)

		err = ioutil.WriteFile(varsFile, []byte(options.TfVars), 0644)
		if err != nil {
			err = fmt.Errorf("could not write run.auto.tfvars: %w", err)
			return
		}

		defer func() {
			err := os.Remove(varsFile)
			if err != nil {
				fmt.Printf("Could not remove run.auto.tfvars: %v", err)
			}
		}()
	}

	fmt.Print("Uploading directory...\n")

	err = client.ConfigurationVersions.Upload(ctx, cv.UploadURL, options.Directory)
	if err != nil {
		err = fmt.Errorf("could not upload directory '%v': %w", options.Directory, err)
		return
	}

	fmt.Print("Done uploading.\n")

	var r *tfe.Run

	// Runs.Create is put within a retry block since this call sporadically
	// fails with a cryptic error 'invalid run parameters'
	// https://github.com/hashicorp/go-tfe/issues/116
	err = retry.Do(func() error {
		rOptions := tfe.RunCreateOptions{
			Workspace:            w,
			ConfigurationVersion: cv,
			Message:              &options.Message,
		}
		r, err = client.Runs.Create(ctx, rOptions)
		if err != nil {
			err = fmt.Errorf("could not create run: %w", err)
			return err
		}
		return nil
	})
	if err != nil {
		return
	}

	runURL := fmt.Sprintf(
		"https://app.terraform.io/app/%v/workspaces/%v/runs/%v",
		options.Organization, options.Workspace, r.ID,
	)

	fmt.Printf("Run %v has been queued\n", r.ID)
	fmt.Printf("View the run online:\n")
	fmt.Printf("%v\n", runURL)

	output.RunURL = runURL

	// If auto apply isn't enabled a run could hang for a long time, even if
	// the run itself wouldn't change anything the previous run could still be
	// blocked waiting for confirmation.
	// Speculative runs can always continue it seems.
	if !options.Speculative && !w.AutoApply {
		fmt.Print("Auto apply isn't enabled, won't wait for completion.\n")
		return
	}

	if !options.WaitForCompletion {
		fmt.Print("Won't wait for completion.\n")
		return
	}

	var prevStatus tfe.RunStatus
	for {
		r, err = client.Runs.Read(ctx, r.ID)
		if err != nil {
			err = fmt.Errorf("could not read run '%v': %v", r.ID, err)
			return
		}

		if prevStatus != r.Status {
			fmt.Printf("Run status: %v\n", prettyPrint(r.Status))
			prevStatus = r.Status
		}

		if isEndStatus(r.Status) {
			break
		}

		time.Sleep(500 * time.Millisecond)
	}

	output.HasChanges = r.HasChanges

	switch r.Status {

	case tfe.RunPlannedAndFinished:
		fmt.Println("Run has been planned, nothing to do.")
	case tfe.RunApplied:
		fmt.Println("Run has been applied!")

	case tfe.RunCanceled:
		err = fmt.Errorf("run %v has been canceled", r.ID)
	case tfe.RunDiscarded:
		err = fmt.Errorf("run %v has been discarded", r.ID)
	case tfe.RunErrored:
		err = fmt.Errorf("run %v has errored", r.ID)
	}

	if err != nil {
		return
	}

	output.TfOutputs, err = retrieveOutputs(ctx, client, w.ID)

	return
}

func isEndStatus(r tfe.RunStatus) bool {
	// All run statuses: https://github.com/hashicorp/go-tfe/blob/v0.7.0/run.go#L46
	switch r {
	case
		tfe.RunPlannedAndFinished,
		tfe.RunApplied,
		tfe.RunCanceled,
		tfe.RunDiscarded,
		tfe.RunErrored:
		return true

	case
		tfe.RunPlanQueued,
		tfe.RunPlanning,
		tfe.RunPlanned,
		tfe.RunPending,
		tfe.RunConfirmed,
		tfe.RunApplyQueued,
		tfe.RunApplying:
		return false

	case
		tfe.RunCostEstimating,
		tfe.RunCostEstimated,
		tfe.RunPolicyChecked,
		tfe.RunPolicyChecking,
		tfe.RunPolicyOverride,
		tfe.RunPolicySoftFailed:
		fmt.Printf("Run is in unexpected / unsupported status %v, finishing process", r)
		return true
	}
	return true
}

func prettyPrint(r tfe.RunStatus) string {
	return strings.ReplaceAll(fmt.Sprintf("%v", r), "_", " ")
}

type minimalTerraformState struct {
	Outputs map[string]terraformOutput `json:"outputs"`
}

type terraformOutput struct {
	Type  string `json:"type"`
	Value string `json:"value"`
}

func retrieveOutputs(ctx context.Context, client *tfe.Client, workspaceID string) (outputs map[string]string, err error) {
	s, err := client.StateVersions.Current(ctx, workspaceID)
	if err != nil {
		err = fmt.Errorf("could not fetch current state: %w", err)
		return
	}

	bytes, err := client.StateVersions.Download(ctx, s.DownloadURL)
	if err != nil {
		err = fmt.Errorf("could not download state version: %w", err)
		return
	}

	var state minimalTerraformState
	err = json.Unmarshal(bytes, &state)
	if err != nil {
		err = fmt.Errorf("could not parse state version: %w", err)
		return
	}

	outputs = map[string]string{}
	for k, v := range state.Outputs {
		outputs[k] = v.Value
	}

	fmt.Printf("Outputs from current state:\n")
	for k, v := range outputs {
		fmt.Printf(" - %v: %v\n", k, v)
	}

	return
}
